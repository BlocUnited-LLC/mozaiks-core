using AuthServer.Api.Shared;
using Microsoft.Extensions.Options;
using System.Net.Http.Json;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;

namespace AuthServer.Api.Services;

public interface IGitHubIntegrationService
{
    Task<GitHubRepoResult> CreateRepositoryAsync(CreateRepoRequest request, CancellationToken cancellationToken);
    Task<bool> PushFilesAsync(string repoFullName, IEnumerable<GitHubFile> files, string commitMessage, string branch = "main", CancellationToken cancellationToken = default);
    Task<bool> CloneTemplateAsync(string templateRepoUrl, string targetRepoFullName, CancellationToken cancellationToken = default);
}

public sealed class CreateRepoRequest
{
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public bool IsPrivate { get; set; } = true;
    public string OwnerId { get; set; } = string.Empty;
    public string AppId { get; set; } = string.Empty;
}

public sealed class GitHubRepoResult
{
    public bool Success { get; set; }
    public string RepoUrl { get; set; } = string.Empty;
    public string CloneUrl { get; set; } = string.Empty;
    public string RepoFullName { get; set; } = string.Empty;
    public string? ErrorMessage { get; set; }
}

public sealed class GitHubFile
{
    public string Path { get; set; } = string.Empty;
    public byte[]? Content { get; set; }
    public string? ContentBase64 { get; set; }
}

public sealed class GitHubIntegrationService : IGitHubIntegrationService
{
    private static readonly JsonSerializerOptions JsonOptions = new(JsonSerializerDefaults.Web);

    private readonly HttpClient _httpClient;
    private readonly GitHubOptions _config;
    private readonly ILogger<GitHubIntegrationService> _logger;

    public GitHubIntegrationService(
        IHttpClientFactory httpClientFactory,
        IOptions<GitHubOptions> config,
        ILogger<GitHubIntegrationService> logger)
    {
        _httpClient = httpClientFactory.CreateClient("GitHub");
        _config = config.Value;
        _logger = logger;
    }

    public async Task<GitHubRepoResult> CreateRepositoryAsync(CreateRepoRequest request, CancellationToken cancellationToken)
    {
        if (string.IsNullOrWhiteSpace(_config.AccessToken) || string.Equals(_config.AccessToken, "replace_me", StringComparison.OrdinalIgnoreCase))
        {
            return new GitHubRepoResult { Success = false, ErrorMessage = "GitHub access token is not configured" };
        }

        try
        {
            var repoName = SanitizeRepoName(request.Name);
            var payload = new
            {
                name = repoName,
                description = request.Description ?? $"Generated by Mozaiks for app {request.AppId}",
                @private = request.IsPrivate,
                auto_init = true
            };

            var endpoint = string.IsNullOrWhiteSpace(_config.OrganizationName)
                ? "user/repos"
                : $"orgs/{_config.OrganizationName}/repos";

            var response = await _httpClient.PostAsJsonAsync(endpoint, payload, cancellationToken);
            if (!response.IsSuccessStatusCode)
            {
                var error = await response.Content.ReadAsStringAsync(cancellationToken);
                _logger.LogError("GitHub repo creation failed: {Status} {Error}", response.StatusCode, error);
                return new GitHubRepoResult
                {
                    Success = false,
                    ErrorMessage = $"GitHub API error: {response.StatusCode}"
                };
            }

            var result = await response.Content.ReadFromJsonAsync<GitHubRepoCreateResponse>(JsonOptions, cancellationToken);
            if (result is null || string.IsNullOrWhiteSpace(result.full_name))
            {
                return new GitHubRepoResult { Success = false, ErrorMessage = "GitHub API returned an unexpected response" };
            }

            return new GitHubRepoResult
            {
                Success = true,
                RepoUrl = result.html_url ?? string.Empty,
                CloneUrl = result.clone_url ?? string.Empty,
                RepoFullName = result.full_name
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create GitHub repo");
            return new GitHubRepoResult
            {
                Success = false,
                ErrorMessage = ex.Message
            };
        }
    }

    public async Task<bool> PushFilesAsync(
        string repoFullName,
        IEnumerable<GitHubFile> files,
        string commitMessage,
        string branch = "main",
        CancellationToken cancellationToken = default)
    {
        var fileList = files
            .Where(f => !string.IsNullOrWhiteSpace(f.Path))
            .ToList();

        if (fileList.Count == 0)
        {
            return true;
        }

        try
        {
            var targetBranch = string.IsNullOrWhiteSpace(branch) ? "main" : branch.Trim();
            await EnsureBranchExistsAsync(repoFullName, targetBranch, cancellationToken);

            var parentSha = await GetRefShaAsync(repoFullName, targetBranch, cancellationToken);

            var blobs = new List<(string path, string sha)>(fileList.Count);
            foreach (var file in fileList)
            {
                var base64 = file.ContentBase64;
                if (string.IsNullOrWhiteSpace(base64) && file.Content is not null)
                {
                    base64 = Convert.ToBase64String(file.Content);
                }

                if (string.IsNullOrWhiteSpace(base64))
                {
                    continue;
                }

                var blobSha = await CreateBlobAsync(repoFullName, base64, cancellationToken);
                blobs.Add((NormalizeGitPath(file.Path), blobSha));
            }

            var treeSha = await CreateTreeAsync(repoFullName, blobs, cancellationToken);
            var commitSha = await CreateCommitAsync(repoFullName, commitMessage, treeSha, parentSha, cancellationToken);
            await UpdateRefAsync(repoFullName, targetBranch, commitSha, cancellationToken);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to push files to GitHub repo {RepoFullName}", repoFullName);
            return false;
        }
    }

    public async Task<bool> CloneTemplateAsync(string templateRepoUrl, string targetRepoFullName, CancellationToken cancellationToken = default)
    {
        try
        {
            var (owner, repo) = ParseGitHubOwnerRepo(templateRepoUrl);
            if (string.IsNullOrWhiteSpace(owner) || string.IsNullOrWhiteSpace(repo))
            {
                return false;
            }

            var zip = await _httpClient.GetAsync($"repos/{owner}/{repo}/zipball", cancellationToken);
            if (!zip.IsSuccessStatusCode)
            {
                return false;
            }

            var bytes = await zip.Content.ReadAsByteArrayAsync(cancellationToken);
            var extracted = ZipBundleExtractor.ExtractFiles(bytes);
            return await PushFilesAsync(targetRepoFullName, extracted.Select(kvp => new GitHubFile
            {
                Path = kvp.Key,
                Content = kvp.Value
            }), "Clone template", "main", cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "CloneTemplateAsync failed");
            return false;
        }
    }

    private async Task EnsureBranchExistsAsync(string repoFullName, string branch, CancellationToken cancellationToken)
    {
        try
        {
            _ = await GetRefShaAsync(repoFullName, branch, cancellationToken);
        }
        catch (HttpRequestException)
        {
            var repo = await _httpClient.GetFromJsonAsync<GitHubRepoDetails>($"repos/{repoFullName}", JsonOptions, cancellationToken);
            if (repo is null || string.IsNullOrWhiteSpace(repo.default_branch))
            {
                throw;
            }

            var baseSha = await GetRefShaAsync(repoFullName, repo.default_branch, cancellationToken);

            var createRef = new
            {
                @ref = $"refs/heads/{branch}",
                sha = baseSha
            };

            var resp = await _httpClient.PostAsJsonAsync($"repos/{repoFullName}/git/refs", createRef, cancellationToken);
            resp.EnsureSuccessStatusCode();
        }
    }

    private async Task<string> GetRefShaAsync(string repoFullName, string branch, CancellationToken cancellationToken)
    {
        var response = await _httpClient.GetAsync($"repos/{repoFullName}/git/ref/heads/{branch}", cancellationToken);
        response.EnsureSuccessStatusCode();
        var data = await response.Content.ReadFromJsonAsync<GitHubRefResponse>(JsonOptions, cancellationToken);
        var sha = data?.Object?.Sha;
        if (string.IsNullOrWhiteSpace(sha))
        {
            throw new InvalidOperationException("GitHub ref response missing sha");
        }

        return sha;
    }

    private async Task<string> CreateBlobAsync(string repoFullName, string contentBase64, CancellationToken cancellationToken)
    {
        var payload = new
        {
            content = contentBase64,
            encoding = "base64"
        };

        var response = await _httpClient.PostAsJsonAsync($"repos/{repoFullName}/git/blobs", payload, cancellationToken);
        response.EnsureSuccessStatusCode();
        var data = await response.Content.ReadFromJsonAsync<GitHubBlobResponse>(JsonOptions, cancellationToken);
        var sha = data?.sha;
        if (string.IsNullOrWhiteSpace(sha))
        {
            throw new InvalidOperationException("GitHub blob response missing sha");
        }

        return sha;
    }

    private async Task<string> CreateTreeAsync(string repoFullName, List<(string path, string sha)> blobs, CancellationToken cancellationToken)
    {
        var payload = new
        {
            tree = blobs.Select(b => new
            {
                path = b.path,
                mode = "100644",
                type = "blob",
                sha = b.sha
            })
        };

        var response = await _httpClient.PostAsJsonAsync($"repos/{repoFullName}/git/trees", payload, cancellationToken);
        response.EnsureSuccessStatusCode();
        var data = await response.Content.ReadFromJsonAsync<GitHubTreeResponse>(JsonOptions, cancellationToken);
        var sha = data?.sha;
        if (string.IsNullOrWhiteSpace(sha))
        {
            throw new InvalidOperationException("GitHub tree response missing sha");
        }

        return sha;
    }

    private async Task<string> CreateCommitAsync(string repoFullName, string message, string treeSha, string parentSha, CancellationToken cancellationToken)
    {
        var payload = new
        {
            message = string.IsNullOrWhiteSpace(message) ? "Update files" : message,
            tree = treeSha,
            parents = new[] { parentSha }
        };

        var response = await _httpClient.PostAsJsonAsync($"repos/{repoFullName}/git/commits", payload, cancellationToken);
        response.EnsureSuccessStatusCode();
        var data = await response.Content.ReadFromJsonAsync<GitHubCommitResponse>(JsonOptions, cancellationToken);
        var sha = data?.sha;
        if (string.IsNullOrWhiteSpace(sha))
        {
            throw new InvalidOperationException("GitHub commit response missing sha");
        }

        return sha;
    }

    private async Task UpdateRefAsync(string repoFullName, string branch, string sha, CancellationToken cancellationToken)
    {
        var payload = new
        {
            sha,
            force = true
        };

        var request = new HttpRequestMessage(new HttpMethod("PATCH"), $"repos/{repoFullName}/git/refs/heads/{branch}")
        {
            Content = JsonContent.Create(payload)
        };

        var response = await _httpClient.SendAsync(request, cancellationToken);
        response.EnsureSuccessStatusCode();
    }

    private static string SanitizeRepoName(string name)
    {
        var trimmed = (name ?? string.Empty).Trim();
        if (string.IsNullOrWhiteSpace(trimmed))
        {
            return $"mozaiks-app-{Guid.NewGuid():N}";
        }

        var sanitized = Regex.Replace(trimmed.ToLowerInvariant(), @"[^a-z0-9\-_]", "-");
        sanitized = Regex.Replace(sanitized, @"-+", "-").Trim('-');

        return string.IsNullOrWhiteSpace(sanitized) ? $"mozaiks-app-{Guid.NewGuid():N}" : sanitized;
    }

    private static string NormalizeGitPath(string path)
        => path.Replace('\\', '/').TrimStart('/').Trim();

    private static (string owner, string repo) ParseGitHubOwnerRepo(string repoUrl)
    {
        if (string.IsNullOrWhiteSpace(repoUrl))
        {
            return (string.Empty, string.Empty);
        }

        var raw = repoUrl.Trim();

        if (raw.Contains("github.com", StringComparison.OrdinalIgnoreCase))
        {
            var uri = new Uri(raw.Replace(".git", string.Empty, StringComparison.OrdinalIgnoreCase));
            var segments = uri.AbsolutePath.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
            return segments.Length >= 2 ? (segments[0], segments[1]) : (string.Empty, string.Empty);
        }

        var parts = raw.Replace(".git", string.Empty, StringComparison.OrdinalIgnoreCase)
            .Split('/', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length >= 2 ? (parts[0], parts[1]) : (string.Empty, string.Empty);
    }

    private sealed record GitHubRepoCreateResponse(string? full_name, string? html_url, string? clone_url);
    private sealed record GitHubRepoDetails(string? default_branch);

    private sealed class GitHubRefResponse
    {
        [JsonPropertyName("object")]
        public GitHubRefObject? Object { get; init; }
    }

    private sealed class GitHubRefObject
    {
        [JsonPropertyName("sha")]
        public string? Sha { get; init; }
    }
    private sealed record GitHubBlobResponse(string? sha);
    private sealed record GitHubTreeResponse(string? sha);
    private sealed record GitHubCommitResponse(string? sha);
}
