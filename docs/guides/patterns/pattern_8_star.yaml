# Pattern 8: Star (Template)
# Use Case: Hub-and-spoke coordination (hub delegates to specialists, specialists return)

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 0: PatternAgent Output
# ═══════════════════════════════════════════════════════════════════════════════
PatternSelection:
  is_multi_workflow: false
  decomposition_reason: null
  pack_name: "Pattern 8 - Star Pack"
  workflows:
    - name: "Pattern8_StarWorkflow"
      role: "primary"
      description: "Coordinator hub delegates to specialists and synthesizes"
      pattern_id: 8
      pattern_name: "Star"

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 1: WorkflowStrategyAgent Output
# ═══════════════════════════════════════════════════════════════════════════════
WorkflowStrategy:
  workflow_name: "Pattern8_StarWorkflow"
  workflow_description: "A central coordinator determines which specialist info is needed, delegates, and synthesizes a final response."
  startup_mode: "UserDriven"
  human_in_loop: true
  pattern:
    - "Star"
  modules:
    # Module 0: Hub analysis
    - module_index: 0
      module_name: "Query Analysis"
      module_description: "CoordinatorAgent analyzes the user request and determines which spokes are needed."
      pattern_id: 8
      pattern_name: "Star"
      agents_needed:
        - "CoordinatorAgent"

    # Module 1: Spoke consultation (as needed)
    - module_index: 1
      module_name: "Spoke Consultation"
      module_description: "SpokeAAgent, SpokeBAgent, and/or SpokeCAgent provide domain-specific information based on coordinator's determination."
      pattern_id: 8
      pattern_name: "Star"
      agents_needed:
        - "SpokeAAgent"
        - "SpokeBAgent"
        - "SpokeCAgent"

    # Module 2: Hub synthesis
    - module_index: 2
      module_name: "Response Synthesis"
      module_description: "CoordinatorAgent synthesizes spoke results into a cohesive final_response."
      pattern_id: 8
      pattern_name: "Star"
      agents_needed:
        - "CoordinatorAgent"

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 2a: StateArchitectAgent Output
# ═══════════════════════════════════════════════════════════════════════════════
StateArchitecture:
  global_context_variables:
    - name: "query_analyzed"
      type: "state"
      purpose: "Whether the coordinator has analyzed the query"
      trigger_hint: "Set by CoordinatorAgent"

    - name: "spoke_a_needed"
      type: "needed_flag"
      purpose: "Whether SpokeAAgent is needed"
      trigger_hint: "Set by CoordinatorAgent"

    - name: "spoke_b_needed"
      type: "needed_flag"
      purpose: "Whether SpokeBAgent is needed"
      trigger_hint: "Set by CoordinatorAgent"

    - name: "spoke_c_needed"
      type: "needed_flag"
      purpose: "Whether SpokeCAgent is needed"
      trigger_hint: "Set by CoordinatorAgent"

    - name: "spoke_a_result"
      type: "content"
      purpose: "SpokeAAgent output"
      trigger_hint: "Set by SpokeAAgent"

    - name: "spoke_b_result"
      type: "content"
      purpose: "SpokeBAgent output"
      trigger_hint: "Set by SpokeBAgent"

    - name: "spoke_c_result"
      type: "content"
      purpose: "SpokeCAgent output"
      trigger_hint: "Set by SpokeCAgent"

    - name: "final_response"
      type: "content"
      purpose: "Coordinator synthesis"
      trigger_hint: "Set by CoordinatorAgent"

    - name: "context_aware"
      type: "config"
      purpose: "Platform context awareness flag"
      trigger_hint: "init"

    - name: "monetization_enabled"
      type: "config"
      purpose: "Platform monetization flag"
      trigger_hint: "init"

  lifecycle_requirements:
    before_chat: null
    after_chat: null

  workflow_dependencies: []

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 2b: UXArchitectAgent Output
# ═══════════════════════════════════════════════════════════════════════════════
UXArchitecture:
  ui_requirements: []

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 3a: AgentRosterAgent Output
# ═══════════════════════════════════════════════════════════════════════════════
AgentRoster:
  agents:
    - agent_name: "CoordinatorAgent"
      objective: "Analyze the query, decide which spokes to consult, and synthesize final_response."
      agent_tools: []
      lifecycle_tools: []
      system_hooks: []
      human_interaction: "context"
      generation_mode: null

    - agent_name: "SpokeAAgent"
      objective: "Provide domain A information and return to coordinator."
      agent_tools: []
      lifecycle_tools: []
      system_hooks: []
      human_interaction: "context"
      generation_mode: null

    - agent_name: "SpokeBAgent"
      objective: "Provide domain B information and return to coordinator."
      agent_tools: []
      lifecycle_tools: []
      system_hooks: []
      human_interaction: "context"
      generation_mode: null

    - agent_name: "SpokeCAgent"
      objective: "Provide domain C information and return to coordinator."
      agent_tools: []
      lifecycle_tools: []
      system_hooks: []
      human_interaction: "context"
      generation_mode: null

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 3b: ToolPlanningAgent Output
# ═══════════════════════════════════════════════════════════════════════════════
ToolPlanning:
  agent_tools:
    - name: "analyze_query"
      agent: "CoordinatorAgent"
      integration: null
      purpose: "Set which spokes are needed"
      interaction_mode: "none"

    - name: "submit_spoke_result"
      agent: "SpokeAAgent"
      integration: null
      purpose: "Store spoke_a_result"
      interaction_mode: "none"

    - name: "submit_spoke_result"
      agent: "SpokeBAgent"
      integration: null
      purpose: "Store spoke_b_result"
      interaction_mode: "none"

    - name: "submit_spoke_result"
      agent: "SpokeCAgent"
      integration: null
      purpose: "Store spoke_c_result"
      interaction_mode: "none"

    - name: "compile_final_response"
      agent: "CoordinatorAgent"
      integration: null
      purpose: "Synthesize final_response"
      interaction_mode: "none"

  lifecycle_tools: []
  system_hooks: []

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 4: ProjectOverviewAgent Output
# ═══════════════════════════════════════════════════════════════════════════════
MermaidSequenceDiagram:
  workflow_name: "Pattern 8 - Star"
  mermaid_diagram: |
    sequenceDiagram
        participant User
        participant CoordinatorAgent
        participant SpokeAAgent
        participant SpokeBAgent
        participant SpokeCAgent

        User->>CoordinatorAgent: Query
        CoordinatorAgent->>CoordinatorAgent: analyze_query()
        alt spoke A needed
          CoordinatorAgent->>SpokeAAgent: Delegate
          SpokeAAgent->>SpokeAAgent: submit_spoke_result()
          SpokeAAgent->>CoordinatorAgent: Return
        end
        alt spoke B needed
          CoordinatorAgent->>SpokeBAgent: Delegate
          SpokeBAgent->>SpokeBAgent: submit_spoke_result()
          SpokeBAgent->>CoordinatorAgent: Return
        end
        alt spoke C needed
          CoordinatorAgent->>SpokeCAgent: Delegate
          SpokeCAgent->>SpokeCAgent: submit_spoke_result()
          SpokeCAgent->>CoordinatorAgent: Return
        end
        CoordinatorAgent->>CoordinatorAgent: compile_final_response()
        CoordinatorAgent->>User: Final response
  legend:
    - "Star: hub delegates to spokes and synthesizes"

agent_message: "Review the star pattern diagram and approve generation."

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 5: ContextVariablesAgent Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
ContextVariablesPlan:
  definitions:
    - name: "context_aware"
      type: "config"
      description: "Platform context awareness flag"
      source: { type: "config", trigger: "init" }

    - name: "monetization_enabled"
      type: "config"
      description: "Platform monetization flag"
      source: { type: "config", trigger: "init" }

    - name: "query_analyzed"
      type: "state"
      description: "Coordinator has analyzed"
      source: { type: "state", trigger: "agent_text" }

    - name: "spoke_a_needed"
      type: "needed_flag"
      description: "Need spoke A"
      source: { type: "needed_flag", trigger: "agent_text" }

    - name: "spoke_b_needed"
      type: "needed_flag"
      description: "Need spoke B"
      source: { type: "needed_flag", trigger: "agent_text" }

    - name: "spoke_c_needed"
      type: "needed_flag"
      description: "Need spoke C"
      source: { type: "needed_flag", trigger: "agent_text" }

    - name: "spoke_a_result"
      type: "content"
      description: "Spoke A result"
      source: { type: "content", trigger: "agent_text" }

    - name: "spoke_b_result"
      type: "content"
      description: "Spoke B result"
      source: { type: "content", trigger: "agent_text" }

    - name: "spoke_c_result"
      type: "content"
      description: "Spoke C result"
      source: { type: "content", trigger: "agent_text" }

    - name: "final_response"
      type: "content"
      description: "Synthesis"
      source: { type: "content", trigger: "agent_text" }

  agents:
    - agent: "CoordinatorAgent"
      variables: ["query_analyzed", "spoke_a_needed", "spoke_b_needed", "spoke_c_needed", "final_response"]
    - agent: "SpokeAAgent"
      variables: ["spoke_a_result"]
    - agent: "SpokeBAgent"
      variables: ["spoke_b_result"]
    - agent: "SpokeCAgent"
      variables: ["spoke_c_result"]

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 6: ToolsManagerAgent Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
tools:
  - agent: "CoordinatorAgent"
    file: "tools/analyze_query.py"
    function: "analyze_query"
    description: "Set which spokes are needed"
    tool_type: "Agent_Tool"
    auto_invoke: false
    integration: null
    ui: null

  - agent: "SpokeAAgent"
    file: "tools/submit_spoke_result_a.py"
    function: "submit_spoke_result"
    description: "Store spoke_a_result"
    tool_type: "Agent_Tool"
    auto_invoke: false
    integration: null
    ui: null

  - agent: "SpokeBAgent"
    file: "tools/submit_spoke_result_b.py"
    function: "submit_spoke_result"
    description: "Store spoke_b_result"
    tool_type: "Agent_Tool"
    auto_invoke: false
    integration: null
    ui: null

  - agent: "SpokeCAgent"
    file: "tools/submit_spoke_result_c.py"
    function: "submit_spoke_result"
    description: "Store spoke_c_result"
    tool_type: "Agent_Tool"
    auto_invoke: false
    integration: null
    ui: null

  - agent: "CoordinatorAgent"
    file: "tools/compile_final_response.py"
    function: "compile_final_response"
    description: "Synthesize final_response"
    tool_type: "Agent_Tool"
    auto_invoke: false
    integration: null
    ui: null

lifecycle_tools: []

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 7a: UIFileGenerator Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
tools: []

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 7b: AgentToolsFileGenerator Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
tools:
  - filename: "tools/analyze_query.py"
    installRequirements: []
    content: |
      from __future__ import annotations

      from typing import Any, Dict


      async def analyze_query(query: str) -> Dict[str, Any]:
          # Template: decide which spokes are needed.
          return {"ok": True, "spoke_a_needed": True, "spoke_b_needed": True, "spoke_c_needed": False}

  - filename: "tools/submit_spoke_result_a.py"
    installRequirements: []
    content: |
      from __future__ import annotations

      from typing import Any, Dict


      async def submit_spoke_result(result: str) -> Dict[str, Any]:
          return {"ok": True, "result": result}

  - filename: "tools/submit_spoke_result_b.py"
    installRequirements: []
    content: |
      from __future__ import annotations

      from typing import Any, Dict


      async def submit_spoke_result(result: str) -> Dict[str, Any]:
          return {"ok": True, "result": result}

  - filename: "tools/submit_spoke_result_c.py"
    installRequirements: []
    content: |
      from __future__ import annotations

      from typing import Any, Dict


      async def submit_spoke_result(result: str) -> Dict[str, Any]:
          return {"ok": True, "result": result}

  - filename: "tools/compile_final_response.py"
    installRequirements: []
    content: |
      from __future__ import annotations

      from typing import Any, Dict


      async def compile_final_response(a: str = "", b: str = "", c: str = "") -> Dict[str, Any]:
          return {"ok": True, "final_response": "\n".join([x for x in [a, b, c] if x])}

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 7c: HookAgent Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
hook_files: []

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 8: AgentsAgent Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
agents:
  - name: "CoordinatorAgent"
    display_name: "Coordinator"
    prompt_sections:
      - id: "role"
        heading: "[ROLE]"
        content: "You are the hub coordinator. Decide which spokes to consult and synthesize a final response."

      - id: "objective"
        heading: "[OBJECTIVE]"
        content: |
          - Analyze the user request
          - Decide which spokes are needed (A/B/C)
          - Synthesize a final_response from spoke results

      - id: "context"
        heading: "[CONTEXT]"
        content: |
          **Context Variables**:
          - spoke_a_needed / spoke_b_needed / spoke_c_needed
          - spoke_a_result / spoke_b_result / spoke_c_result

          **Tools**:
          - compile_final_response(a: str, b: str, c: str)

      - id: "instructions"
        heading: "[INSTRUCTIONS]"
        content: |
          1. Determine which spokes are relevant.
          2. Trigger handoffs to the needed spokes.
          3. When results are available, call compile_final_response.
          4. Return the synthesized answer to the user.

      - id: "output_format"
        heading: "[OUTPUT FORMAT]"
        content: "Conversational. Provide a concise synthesized answer with clear next steps."
    max_consecutive_auto_reply: 15
    auto_tool_mode: true
    structured_outputs_required: false

  - name: "SpokeAAgent"
    display_name: "Spoke A"
    prompt_sections:
      - id: "role"
        heading: "[ROLE]"
        content: "You are a specialist spoke for domain A."

      - id: "objective"
        heading: "[OBJECTIVE]"
        content: |
          - Provide domain A information relevant to the user request
          - Store the result for the coordinator

      - id: "context"
        heading: "[CONTEXT]"
        content: |
          **Tool**: submit_spoke_result(result: str)
          Output is stored as spoke_a_result.

      - id: "instructions"
        heading: "[INSTRUCTIONS]"
        content: |
          1. Answer only the domain A portion of the request.
          2. Keep the response concise and actionable.
          3. Call submit_spoke_result with your result.
          4. Handoff back to CoordinatorAgent.

      - id: "output_format"
        heading: "[OUTPUT FORMAT]"
        content: "Bullet list of domain A findings and recommendations."
    max_consecutive_auto_reply: 10
    auto_tool_mode: false
    structured_outputs_required: false

  - name: "SpokeBAgent"
    display_name: "Spoke B"
    prompt_sections:
      - id: "role"
        heading: "[ROLE]"
        content: "You are a specialist spoke for domain B."

      - id: "objective"
        heading: "[OBJECTIVE]"
        content: |
          - Provide domain B information relevant to the user request
          - Store the result for the coordinator

      - id: "context"
        heading: "[CONTEXT]"
        content: |
          **Tool**: submit_spoke_result(result: str)
          Output is stored as spoke_b_result.

      - id: "instructions"
        heading: "[INSTRUCTIONS]"
        content: |
          1. Answer only the domain B portion of the request.
          2. Keep the response concise and actionable.
          3. Call submit_spoke_result with your result.
          4. Handoff back to CoordinatorAgent.

      - id: "output_format"
        heading: "[OUTPUT FORMAT]"
        content: "Bullet list of domain B findings and recommendations."
    max_consecutive_auto_reply: 10
    auto_tool_mode: false
    structured_outputs_required: false

  - name: "SpokeCAgent"
    display_name: "Spoke C"
    prompt_sections:
      - id: "role"
        heading: "[ROLE]"
        content: "You are a specialist spoke for domain C."

      - id: "objective"
        heading: "[OBJECTIVE]"
        content: |
          - Provide domain C information relevant to the user request
          - Store the result for the coordinator

      - id: "context"
        heading: "[CONTEXT]"
        content: |
          **Tool**: submit_spoke_result(result: str)
          Output is stored as spoke_c_result.

      - id: "instructions"
        heading: "[INSTRUCTIONS]"
        content: |
          1. Answer only the domain C portion of the request.
          2. Keep the response concise and actionable.
          3. Call submit_spoke_result with your result.
          4. Handoff back to CoordinatorAgent.

      - id: "output_format"
        heading: "[OUTPUT FORMAT]"
        content: "Bullet list of domain C findings and recommendations."
    max_consecutive_auto_reply: 10
    auto_tool_mode: false
    structured_outputs_required: false

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 9: OrchestratorAgent Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
workflow_name: "Pattern8_StarWorkflow"
max_turns: 60
human_in_the_loop: true
startup_mode: "UserDriven"
orchestration_pattern: "Star"
initial_message_to_user: null
initial_message: "Tell me what you need; I will consult specialists and synthesize."
initial_agent: "CoordinatorAgent"
visual_agents: []

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 10: HandoffsAgent Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
handoff_rules:
  - source_agent: "CoordinatorAgent"
    target_agent: "SpokeAAgent"
    handoff_type: "condition"
    condition: "spoke_a_needed is true"
    condition_type: "StringLLMCondition"
    condition_scope: null
    transition_target: "AgentTarget"

  - source_agent: "CoordinatorAgent"
    target_agent: "SpokeBAgent"
    handoff_type: "condition"
    condition: "spoke_b_needed is true"
    condition_type: "StringLLMCondition"
    condition_scope: null
    transition_target: "AgentTarget"

  - source_agent: "CoordinatorAgent"
    target_agent: "SpokeCAgent"
    handoff_type: "condition"
    condition: "spoke_c_needed is true"
    condition_type: "StringLLMCondition"
    condition_scope: null
    transition_target: "AgentTarget"

  - source_agent: "CoordinatorAgent"
    target_agent: "User"
    handoff_type: "after_work"
    condition: null
    condition_type: null
    condition_scope: null
    transition_target: "RevertToUserTarget"

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 11: StructuredOutputsAgent Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
models: []

registry:
  - agent: "CoordinatorAgent"
    agent_definition: null
  - agent: "SpokeAAgent"
    agent_definition: null
  - agent: "SpokeBAgent"
    agent_definition: null
  - agent: "SpokeCAgent"
    agent_definition: null

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 12: PackMetadataAgent Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
PackMetadata:
  manifest:
    pack_name: "Pattern 8 - Star Pack"
    pack_description: "Template pack for Pattern 8 Star"
    version: "1.0.0"
    entry_point: "Pattern8_StarWorkflow"
    workflows:
      - name: "Pattern8_StarWorkflow"
        description: "Hub-and-spoke coordination"
        role: "primary"
        startup_mode: "UserDriven"
    ui_config:
      show_workflow_transitions: false
      transition_style: "hidden"

  workflow_graph:
    nodes:
      - id: "Pattern8_StarWorkflow"
        type: "primary"
    edges: []

  shared_context:
    variables: []
    refresh_strategy: "explicit"
    db_collection: "shared_context"

---
# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 13: DownloadAgent Output (BUILD PHASE)
# ═══════════════════════════════════════════════════════════════════════════════
agent_message: "Your star workflow template is ready to download. Generate the bundle now?"
