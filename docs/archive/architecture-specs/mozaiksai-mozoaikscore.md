# UI Ownership Boundaries (Source of Truth)

This document defines which UI belongs in **AI Plugins** (ChatUI + artifacts) vs what should live in **Function Plugins** (product pages + APIs).

**Key Entities:**
- **MozaiksCore** = Pre-built plugin foundation (auth, billing, plugin host, theming, etc.)
- **MozaiksAI** = Embeddable runtime + ChatUI (workflows, agents, artifacts) which is embedded into MozaiksCore
- **AgentGenerator** = Agentic workflow that produces MozaiksCore **AI Plugins** (workflows, tools, artifacts)
- **AppGenerator** = Agentic workflow that produces MozaiksCore **Function Plugins** (pages, APIs, components)

```
┌─────────────────────────────────────────────────────────────────────┐
│  MozaiksCore (Pre-Built Foundation)                                 │
│  • Auth, Billing, Plugin Host, Theming, Notifications               │
│  • MozaiksAI Runtime embedded (ChatUI, WebSocket, Workflow Engine)  │
│                                                                     │
│  ┌─────────────────────────────┐  ┌─────────────────────────────┐  │
│  │  Function Plugin A          │  │  AI Plugin A                │  │
│  │  (generated by AppGenerator)│  │  (generated by AgentGen)    │  │
│  │  • Pages, APIs, Components  │  │  • Workflows, Tools, Artifacts│ │
│  └─────────────────────────────┘  └─────────────────────────────┘  │
│                                                                     │
│  ┌─────────────────────────────┐  ┌─────────────────────────────┐  │
│  │  Function Plugin B          │  │  AI Plugin B                │  │
│  │  (generated by AppGenerator)│  │  (generated by AgentGen)    │  │
│  │  • Pages, APIs, Components  │  │  • Workflows, Tools, Artifacts│ │
│  └─────────────────────────────┘  └─────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

The intent is to keep MozaiksAI **embeddable**: it provides the runtime and ChatUI that MozaiksCore uses to execute AI plugins.

---

## Core Principle: AI Plugin vs Function Plugin UI

### AI Plugin UI (Chat-Native) — Created by AgentGenerator
UI that is **best expressed as an agent conversation + tool-driven workspace**.

- The user is collaborating with agents.
- The UI state is driven by workflow/tool events.
- The "page" can change shape as the agent progresses.
- The UX is naturally tied to a **chat_id** and a workflow run.

In practice: these are **Artifacts / Inline Components** rendered by ChatUI, attached to a workflow.

### Function Plugin UI (Product-Native) — Created by AppGenerator
UI that is **part of a normal product**.

- Navigation, routing, global search, lists, settings pages.
- Account/team/org management, permissions, billing.
- Marketplace browsing, installation flows, approvals.
- Stable dashboards with deterministic interactions.

These surfaces belong in Function Plugins so they can conform to standard product UX patterns, security models, and platform conventions.

---

## What MozaiksCore Is (Pre-Built Foundation)

MozaiksCore is the **plugin host framework** — it is NOT generated, it is pre-built. It provides:

- Authentication/authorization (SSO/OIDC, RBAC/ABAC)
- User/team/org management
- Billing/subscriptions/entitlements
- Plugin host and module loading
- Theming and branding system
- Notification system (in-app + email)
- Settings management
- Auditing and admin tooling
- Session Broker (auth gateway to MozaiksAI runtime)

> **Implementation Note:** For the Mozaiks platform itself, MozaiksCore is implemented in .NET. Future apps built on the platform will have AppGenerator produce Python/JS backends.

### Session Broker vs Session Management

| Concept | Owner | Responsibility |
|---------|-------|----------------|
| **Session Broker** | MozaiksCore | Auth gateway — validates JWT, checks subscriptions, authorizes access to runtime |
| **Session Management** | MozaiksAI Runtime | Workflow state — tracks active workflows, pauses/resumes, artifact persistence |

```
Browser → MozaiksCore (auth/proxy) → MozaiksAI Runtime (workflow execution)
            ↑                              ↑
        Session Broker              Session Management
```

---

## Session Broker (Deep Dive)

The **Session Broker** is the auth gateway that sits between the frontend and MozaiksAI Runtime. It lives in MozaiksCore (for Full Platform) or in the host app's backend (for Standalone integration).

### Why It Exists

MozaiksAI Runtime is **auth-agnostic** — it doesn't know about your users, subscriptions, or entitlements. It just executes workflows for whoever connects. The Session Broker is the gatekeeper that:

1. **Validates identity** — Is this a real, authenticated user?
2. **Checks entitlements** — Can this user run this workflow?
3. **Creates sessions** — Tells the runtime to start/resume a chat
4. **Returns connection info** — Gives the frontend the WebSocket URL + short-lived token

### The Flow

```
┌──────────────┐         ┌─────────────────────┐         ┌──────────────────┐
│   Browser    │         │    Session Broker   │         │ MozaiksAI Runtime│
│  (ChatUI)    │         │    (MozaiksCore)    │         │    (Python)      │
└──────┬───────┘         └──────────┬──────────┘         └────────┬─────────┘
       │                            │                             │
       │  1. "Start workflow X"     │                             │
       │     + user's JWT           │                             │
       │ ─────────────────────────► │                             │
       │                            │                             │
       │                            │  2. Validate JWT            │
       │                            │     (signature, expiry,     │
       │                            │      claims)                │
       │                            │                             │
       │                            │  3. Check entitlements      │
       │                            │     - Does user have        │
       │                            │       access to workflow X? │
       │                            │     - Is subscription active?│
       │                            │     - Usage limits OK?      │
       │                            │                             │
       │                            │  4. Create/resume session   │
       │                            │ ────────────────────────────►
       │                            │                             │
       │                            │  5. { chat_id, status }     │
       │                            │ ◄────────────────────────────
       │                            │                             │
       │  6. { chat_id, ws_url,     │                             │
       │       runtime_token }      │                             │
       │ ◄───────────────────────── │                             │
       │                            │                             │
       │  7. Connect WebSocket directly to runtime                │
       │     (with runtime_token for auth)                        │
       │ ─────────────────────────────────────────────────────────►
       │                            │                             │
```

### Session Broker Responsibilities

| Responsibility | What It Does |
|----------------|--------------|
| **JWT Validation** | Verifies the user's token is valid, not expired, properly signed |
| **User Resolution** | Extracts `user_id`, `tenant_id`, `app_id` from token claims |
| **Entitlement Check** | Queries subscription/permissions to see if user can run this workflow |
| **Usage Gating** | Checks if user has exceeded token limits, rate limits, etc. |
| **Session Creation** | Calls runtime API to create or resume a chat session |
| **Token Minting** | Creates a short-lived runtime token for WebSocket auth |
| **URL Construction** | Builds the WebSocket URL with proper routing params |

### Session Broker Endpoints

```
POST /api/mozaiks/sessions
  → Create or resume a workflow session
  
  Request:
  {
    "workflow_name": "campaign-builder",
    "chat_id": null,           // null = new session, value = resume
    "context": { ... }         // optional context to pass to workflow
  }
  
  Response:
  {
    "chat_id": "abc-123",
    "workflow_name": "campaign-builder",
    "status": "created" | "resumed",
    "ws_url": "wss://runtime.mozaiks.io/ws/campaign-builder/app-id/abc-123/user-id",
    "runtime_token": "eyJ...",  // short-lived token (e.g., 15 min)
    "expires_at": "2024-12-24T12:30:00Z"
  }

GET /api/mozaiks/sessions
  → List user's active/recent sessions
  
  Response:
  {
    "sessions": [
      { "chat_id": "abc-123", "workflow_name": "campaign-builder", "status": "active", "created_at": "..." },
      { "chat_id": "def-456", "workflow_name": "agent-generator", "status": "completed", "created_at": "..." }
    ]
  }

GET /api/mozaiks/workflows
  → List workflows available to this user (based on entitlements)
  
  Response:
  {
    "workflows": [
      { "name": "campaign-builder", "display_name": "Campaign Builder", "description": "..." },
      { "name": "agent-generator", "display_name": "Agent Generator", "description": "..." }
    ]
  }
```

### Runtime Token vs User JWT

| Token | Issued By | Lifetime | Purpose |
|-------|-----------|----------|---------|
| **User JWT** | MozaiksCore Auth | Long (hours/days) | Identifies the user across all MozaiksCore services |
| **Runtime Token** | Session Broker | Short (15 min) | Authorizes a specific WebSocket connection to runtime |

The Runtime Token is scoped to:
- A specific `chat_id`
- A specific `user_id`
- A specific `app_id`
- A short time window

This means even if leaked, it can only be used for that one chat session.

### Implementation in MozaiksCore (C#/.NET)

```csharp
[ApiController]
[Route("api/mozaiks")]
[Authorize] // Requires valid user JWT
public class SessionBrokerController : ControllerBase
{
    private readonly IMozaiksRuntimeClient _runtimeClient;
    private readonly IEntitlementService _entitlements;
    private readonly IRuntimeTokenService _tokenService;
    
    [HttpPost("sessions")]
    public async Task<IActionResult> CreateSession([FromBody] CreateSessionRequest request)
    {
        // 1. Extract user from JWT claims
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        var tenantId = User.FindFirst("tenant_id")?.Value;
        var appId = User.FindFirst("app_id")?.Value ?? "mozaiks-core";
        
        // 2. Check entitlements
        var canRun = await _entitlements.CanRunWorkflowAsync(
            userId, 
            tenantId, 
            request.WorkflowName
        );
        
        if (!canRun.Allowed)
        {
            return Forbid(canRun.Reason); // "Subscription required" / "Usage limit exceeded"
        }
        
        // 3. Create/resume session in runtime
        var session = await _runtimeClient.CreateSessionAsync(new RuntimeSessionRequest
        {
            AppId = appId,
            UserId = userId,
            WorkflowName = request.WorkflowName,
            ChatId = request.ChatId, // null = new, value = resume
            Context = request.Context
        });
        
        // 4. Mint short-lived runtime token
        var runtimeToken = _tokenService.CreateRuntimeToken(new RuntimeTokenClaims
        {
            UserId = userId,
            AppId = appId,
            ChatId = session.ChatId,
            ExpiresIn = TimeSpan.FromMinutes(15)
        });
        
        // 5. Build WebSocket URL
        var wsUrl = $"{_config.RuntimeWsBaseUrl}/ws/{request.WorkflowName}/{appId}/{session.ChatId}/{userId}";
        
        return Ok(new CreateSessionResponse
        {
            ChatId = session.ChatId,
            WorkflowName = request.WorkflowName,
            Status = session.IsNew ? "created" : "resumed",
            WsUrl = wsUrl,
            RuntimeToken = runtimeToken,
            ExpiresAt = DateTime.UtcNow.AddMinutes(15)
        });
    }
}
```

### ChatUI Integration

ChatUI calls the Session Broker automatically when launching a workflow:

```tsx
// Inside ChatUI — this happens automatically
const { openWorkflow } = useChatUI();

// When user clicks "Build Campaign"
await openWorkflow('campaign-builder');

// Under the hood:
// 1. ChatUI calls POST /api/mozaiks/sessions with user's JWT
// 2. Session Broker validates, checks entitlements, creates session
// 3. Session Broker returns { chat_id, ws_url, runtime_token }
// 4. ChatUI connects WebSocket to ws_url with runtime_token
// 5. Workflow begins
```

### Session Broker in Standalone vs Full Platform

| Aspect | Full Platform (MozaiksCore) | Standalone (Host App) |
|--------|----------------------------|----------------------|
| Where it lives | Built into MozaiksCore | Host app must implement it |
| Auth integration | Uses MozaiksCore auth | Uses host app's existing auth |
| Entitlements | Uses MozaiksCore subscriptions | Host app defines entitlements |
| Token minting | MozaiksCore token service | Host app mints runtime tokens |

In Standalone integration, the host app must implement Session Broker endpoints that:
- Use their existing auth system
- Apply their own entitlement logic
- Call MozaiksAI Runtime to create sessions
- Return the same response shape ChatUI expects

---

## What AI Plugins Contain (AgentGenerator Output)

### 1) Chat Shell + Overlay (always MozaiksAI)
MozaiksAI ships a stable UI surface that can be embedded as an overlay/widget in any app.

- Persistent chat widget / bubble / overlay entry points
- Chat session rendering + streaming
- Artifact host surfaces (side panel, inline components)
- Mode switching (workflow mode vs ask mode)

MozaiksAI should **not** attempt to own product navigation or pages. It should be a drop-in "agent surface".

### 2) Artifact UIs for Agent-Heavy Workspaces
Workflow-specific UIs that are strongly coupled to tool calls belong under:

- `ChatUI/src/workflows/{workflow_name}/components/`

Examples of "artifact-native" UIs:
- AgentGenerator workspace (designing agents, validating JSON, previewing outputs)
- A "campaign builder" canvas that agents keep updating as they reason
- An AI-assisted onboarding interview with a generated summary workspace

### 3) Workflow Orchestration + Real-Time Transport
The runtime owns:
- WebSocket transport and session correlation
- Workflow execution + persistence (Mongo)
- Pack gating / journey sequencing
- Tool boundary enforcement (argument schema validation)

The runtime should remain **product-agnostic**: it executes declarative workflows and emits events; it does not implement product pages.

### AI Plugin Structure (Generated by AgentGenerator)

| Output | Location | Purpose |
|--------|----------|---------|
| Workflow JSON | `workflows/{name}/orchestrator.json` | Workflow configuration |
| Agent definitions | `workflows/{name}/agents.json` | Agent roles and prompts |
| Tool stubs | `workflows/{name}/tools/` | Python callables for agent actions |
| Artifact components | `ChatUI/src/workflows/{name}/components/` | React components for chat workspaces |
| Handoff rules | `workflows/{name}/handoffs.json` | Agent-to-agent transitions |

---

## What Function Plugins Contain (AppGenerator Output)

AppGenerator is an **agentic workflow** that generates Function Plugin files. These plugins run on MozaiksCore alongside AI Plugins.

### Function Plugin Structure (Generated by AppGenerator)

```
plugins/{plugin-name}/
├── manifest.json              # Plugin registration with MozaiksCore
├── api/                       # Backend routes (CRUD, queries, webhooks)
├── pages/                     # Product pages (list, detail, dashboard)
├── components/                # UI components (cards, forms, widgets)
├── hooks/                     # Data fetching, state management
├── services/                  # Backend business logic
└── types/                     # TypeScript interfaces
```

### What Function Plugins Contain

| Output | Purpose |
|--------|---------|
| Plugin manifest | Registration, permissions, navigation entries |
| API routes | CRUD operations, analytics queries, integration webhooks |
| Pages | List, detail, dashboard, settings views |
| Components | Cards, tables, forms, widgets |
| Hooks | Data fetching, real-time subscriptions |
| Services | OAuth flows, external API calls, domain logic |
| Types | TypeScript/Python interfaces |

### Function Plugin Capabilities

Function Plugins can:
- Add navigation entries to MozaiksCore sidebar
- Define product pages (lists, dashboards, settings)
- Expose backend APIs
- Handle OAuth flows for 3rd-party platforms
- Call external vendor APIs
- Emit events to the economic protocol
- **Launch AI Plugin workflows** (the key integration point)

Key rule: Function Plugin pages can *launch* AI Plugin experiences (open chat overlay, deep link into a workflow), but they should not re-implement the chat surface.

---

## Marketplace / App Store Example

Marketplace browsing and purchasing is product-native.

- The marketplace UI should live in MozaiksCore.
- Installing an "agent app" should result in:
  - pack/workflow availability changes (server-side entitlement)
  - the ability to launch a chat/workflow from the marketplace item

MozaiksAI should not try to be a marketplace shell; it should be the consistent agent surface that the marketplace launches.

## Summary: Three Distinct Things

| Thing | What It Is | Created By |
|-------|------------|------------|
| **MozaiksCore** | Pre-built foundation (auth, billing, plugin host) + embedded MozaiksAI runtime | Built once, not generated |
| **Function Plugin** | Product pages, APIs, components for a specific app | AppGenerator workflow |
| **AI Plugin** | Workflows, agents, tools, artifacts for chat-native experiences | AgentGenerator workflow |

---

## Practical Decision Rules (Use This When Unsure)

Put UI **inside an AI Plugin** when:
- The UI is primarily a workspace that agents continuously update.
- The user expects to converse, refine, and iterate.
- The state belongs to a specific chat/workflow run.
- The UI is tightly coupled to tool calls and agent steps.

Put UI **inside a Function Plugin** when:
- It's navigation, browsing, search, or inventory (marketplace, lists).
- It's security/permissions/billing/approvals.
- It needs stable, deterministic CRUD with strict validation.
- It's a global dashboard spanning many chats/workflows.

A good default is:
- MozaiksCore provides the *foundation* and *runtime*.
- Function Plugins provide *entry points* and *product pages*.
- AI Plugins provide the *agent workspaces*.

---

## Generator Mapping Summary

| Question | Answer | Generator |
|----------|--------|-----------|
| Does the user converse with AI to build/refine it? | Yes → AI Plugin | AgentGenerator |
| Is it a list, dashboard, settings, or admin page? | Yes → Function Plugin | AppGenerator |
| Does it need real-time agent updates during a session? | Yes → AI Plugin | AgentGenerator |
| Is it permissioned, auditable, and exists outside any chat? | Yes → Function Plugin | AppGenerator |
| Does clicking something launch an AI workflow? | Button in Function Plugin, workflow in AI Plugin | Both |

---

## Packaging Implication (Why This Split Helps)

This boundary makes the architecture clear:

- **MozaiksCore** is built once and hosts all plugins (with MozaiksAI runtime embedded)
- **AppGenerator** produces Function Plugins (product pages, APIs)
- **AgentGenerator** produces AI Plugins (workflows, agents, artifacts)
- Both generators are themselves AI Plugins running on MozaiksAI

For enterprise customers:
- Customer can use MozaiksCore as their product shell
- Or embed MozaiksAI runtime into their existing product
- Either way, they get both Function Plugins and AI Plugins working together
