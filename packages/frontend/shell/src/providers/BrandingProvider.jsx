/**
 * Branding Provider
 *
 * Provides branding configuration to the Shell via React Context.
 * Loads branding.json (generated by Platform or customized for self-hosted).
 *
 * @module @mozaiks/shell/providers/BrandingProvider
 */

import React, { createContext, useContext, useState, useEffect, useRef } from 'react';

const BrandingContext = createContext(null);

/**
 * Default branding configuration (fallback if no branding.json exists)
 */
const DEFAULT_BRANDING = {
  version: '1.0.0',
  app: {
    name: 'Mozaiks',
    tagline: 'AI-Powered Workflows',
    logo: null,
    favicon: null
  },
  theme: {
    mode: 'system', // 'light' | 'dark' | 'system'
    colors: {
      primary: '#3B82F6',
      secondary: '#6366F1',
      accent: '#8B5CF6'
    }
  },
  layout: {
    sidebar: {
      position: 'left',
      collapsible: true,
      defaultCollapsed: false
    },
    header: {
      visible: true,
      sticky: true
    }
  }
};

/**
 * Hook to access branding configuration
 * @returns {Object} Branding context value
 */
export const useBranding = () => {
  const context = useContext(BrandingContext);
  if (!context) {
    throw new Error('useBranding must be used within a BrandingProvider');
  }
  return context;
};

/**
 * BrandingProvider Component
 *
 * Provides branding configuration to the application.
 * Supports both static JSON and dynamic configuration loading.
 *
 * @param {Object} props
 * @param {React.ReactNode} props.children - Child components
 * @param {Object} props.config - Optional static branding config (overrides JSON loading)
 * @param {string} props.configPath - Path to branding.json (default: '/branding.json')
 * @param {Function} props.onLoad - Callback when branding is loaded
 * @param {Function} props.onError - Callback on loading error
 */
export const BrandingProvider = ({
  children,
  config = null,
  configPath = '/branding.json',
  onLoad = () => {},
  onError = () => {}
}) => {
  const [branding, setBranding] = useState(config || DEFAULT_BRANDING);
  const [loading, setLoading] = useState(!config);
  const [error, setError] = useState(null);

  // Use refs for callbacks to avoid re-triggering the fetch effect
  const onLoadRef = useRef(onLoad);
  onLoadRef.current = onLoad;
  const onErrorRef = useRef(onError);
  onErrorRef.current = onError;

  useEffect(() => {
    // If static config provided, skip loading
    if (config) {
      setBranding(config);
      setLoading(false);
      onLoadRef.current(config);
      applyBranding(config);
      return;
    }

    const loadBranding = async () => {
      try {
        const response = await fetch(configPath);

        if (!response.ok) {
          // If branding.json doesn't exist, use defaults (common for self-hosted)
          if (response.status === 404) {
            console.log('[BrandingProvider] No branding.json found, using defaults');
            setBranding(DEFAULT_BRANDING);
            setLoading(false);
            onLoadRef.current(DEFAULT_BRANDING);
            applyBranding(DEFAULT_BRANDING);
            return;
          }
          throw new Error(`Failed to load branding config: ${response.status}`);
        }

        const brandingConfig = await response.json();

        // Merge with defaults to ensure all fields exist
        const mergedConfig = deepMerge(DEFAULT_BRANDING, brandingConfig);

        setBranding(mergedConfig);
        setLoading(false);
        onLoadRef.current(mergedConfig);
        applyBranding(mergedConfig);

        if (process.env.NODE_ENV === 'development') {
          console.log('[BrandingProvider] Loaded branding config:', mergedConfig);
        }
      } catch (err) {
        console.error('[BrandingProvider] Error loading branding:', err);
        setError(err);
        setBranding(DEFAULT_BRANDING);
        setLoading(false);
        onErrorRef.current(err);
        applyBranding(DEFAULT_BRANDING);
      }
    };

    loadBranding();
  }, [config, configPath]);

  /**
   * Apply branding to the DOM (CSS variables, document title, etc.)
   */
  const applyBranding = (brandingConfig) => {
    // Set document title
    if (brandingConfig.app?.name) {
      document.title = brandingConfig.app.name;
    }

    // Set favicon if provided
    if (brandingConfig.app?.favicon) {
      const link = document.querySelector("link[rel*='icon']") || document.createElement('link');
      link.type = 'image/x-icon';
      link.rel = 'shortcut icon';
      link.href = brandingConfig.app.favicon;
      document.head.appendChild(link);
    }

    // Apply CSS custom properties for theme colors
    const root = document.documentElement;
    if (brandingConfig.theme?.colors) {
      const { colors } = brandingConfig.theme;
      if (colors.primary) root.style.setProperty('--color-primary', colors.primary);
      if (colors.secondary) root.style.setProperty('--color-secondary', colors.secondary);
      if (colors.accent) root.style.setProperty('--color-accent', colors.accent);
    }

    // Apply theme mode
    if (brandingConfig.theme?.mode) {
      applyThemeMode(brandingConfig.theme.mode);
    }
  };

  /**
   * Apply theme mode (light/dark/system)
   */
  const applyThemeMode = (mode) => {
    const root = document.documentElement;

    if (mode === 'system') {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      root.classList.toggle('dark', prefersDark);
    } else {
      root.classList.toggle('dark', mode === 'dark');
    }
  };

  /**
   * Get app information
   * @returns {Object} App configuration
   */
  const getAppInfo = () => branding.app || {};

  /**
   * Get theme configuration
   * @returns {Object} Theme configuration
   */
  const getTheme = () => branding.theme || {};

  /**
   * Get layout configuration
   * @returns {Object} Layout configuration
   */
  const getLayout = () => branding.layout || {};

  /**
   * Update theme mode at runtime
   * @param {string} mode - 'light' | 'dark' | 'system'
   */
  const setThemeMode = (mode) => {
    setBranding(prev => ({
      ...prev,
      theme: {
        ...prev.theme,
        mode
      }
    }));
    applyThemeMode(mode);
  };

  const contextValue = {
    // State
    branding,
    loading,
    error,

    // Config version
    version: branding.version,

    // Getters
    getAppInfo,
    getTheme,
    getLayout,

    // Setters
    setThemeMode,

    // Convenience accessors
    appName: branding.app?.name || 'Mozaiks',
    appTagline: branding.app?.tagline || '',
    logo: branding.app?.logo,
    theme: branding.theme,
    layout: branding.layout
  };

  return (
    <BrandingContext.Provider value={contextValue}>
      {children}
    </BrandingContext.Provider>
  );
};

/**
 * Deep merge utility for combining default and custom configs
 */
function deepMerge(target, source) {
  const output = { ...target };

  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach(key => {
      if (isObject(source[key])) {
        if (!(key in target)) {
          output[key] = source[key];
        } else {
          output[key] = deepMerge(target[key], source[key]);
        }
      } else {
        output[key] = source[key];
      }
    });
  }

  return output;
}

function isObject(item) {
  return item && typeof item === 'object' && !Array.isArray(item);
}

export default BrandingProvider;
