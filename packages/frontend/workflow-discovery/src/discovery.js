/**
 * @fileoverview Workflow UI Component Auto-Discovery
 * 
 * Automatically scans workflow component directories and generates index.js
 * export files. This eliminates manual maintenance of component exports.
 * 
 * Usage:
 *   - As module: import { WorkflowComponentDiscovery } from '@mozaiks/workflow-ui-discovery'
 *   - As CLI: npx workflow-ui-discover --watch
 *   - At runtime: Called automatically by workflow loader on startup
 * 
 * @module @mozaiks/workflow-ui-discovery
 */

import fs from 'fs';
import path from 'path';

/**
 * Default configuration for component discovery.
 * Can be overridden via constructor options or config file.
 */
const DEFAULT_CONFIG = {
  // Paths to scan for workflow components (relative to workflowsRoot)
  scanPatterns: [
    '*/components/',
    '_shared/components/'
  ],
  
  // Files to exclude from component discovery
  excludeFiles: [
    'index.js',
    'index.ts',
    '*.test.js',
    '*.test.ts',
    '*.spec.js',
    '*.spec.ts',
    '*.stories.js',
    '*.stories.ts',
    '__tests__/**',
    '__mocks__/**'
  ],
  
  // File extensions to include as components
  componentExtensions: ['.js', '.jsx', '.ts', '.tsx'],
  
  // Template for generated index.js files
  indexTemplate: 'esm', // 'esm' | 'cjs' | 'typescript'
  
  // Whether to generate a root registry of all workflows
  generateRootRegistry: true,
  
  // Whether to generate workflow-level index.js files (for workflows with theme_config.json)
  generateWorkflowIndex: true,
  
  // Workflow config file that triggers workflow-level index generation
  workflowConfigFile: 'theme_config.json',
  
  // Header comment for generated files
  generatedFileHeader: `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * 
 * This file is automatically generated by @mozaiks/workflow-ui-discovery.
 * Any manual changes will be overwritten on next generation.
 * 
 * To add components, simply create .js/.jsx/.ts/.tsx files in this directory.
 * The index will be regenerated automatically.
 * 
 * Generated: {{timestamp}}
 */\n\n`,
};

/**
 * Checks if a filename matches any of the exclude patterns.
 * Supports glob-like patterns with * wildcard.
 * 
 * @param {string} filename - The filename to check
 * @param {string[]} excludePatterns - Array of patterns to match against
 * @returns {boolean} True if the file should be excluded
 */
function matchesExcludePattern(filename, excludePatterns) {
  for (const pattern of excludePatterns) {
    // Handle simple wildcard patterns
    if (pattern.includes('*')) {
      const regexPattern = pattern
        .replace(/\./g, '\\.')
        .replace(/\*/g, '.*')
        .replace(/\*\*/g, '.*');
      const regex = new RegExp(`^${regexPattern}$`);
      if (regex.test(filename)) {
        return true;
      }
    } else if (filename === pattern) {
      return true;
    }
  }
  return false;
}

/**
 * Extracts the component name from a filename.
 * Removes extension and handles various naming conventions.
 * 
 * @param {string} filename - The filename (e.g., 'MyComponent.jsx')
 * @returns {string} The component name (e.g., 'MyComponent')
 */
function extractComponentName(filename) {
  // Remove extension
  const name = path.basename(filename).replace(/\.(js|jsx|ts|tsx)$/, '');
  
  // Handle .component suffix (e.g., MyComponent.component.js -> MyComponent)
  return name.replace(/\.component$/, '');
}

/**
 * WorkflowComponentDiscovery - Main class for auto-discovering and indexing components.
 */
export class WorkflowComponentDiscovery {
  /**
   * @param {string} workflowsRoot - Absolute path to the workflows directory
   * @param {Partial<typeof DEFAULT_CONFIG>} options - Configuration options
   */
  constructor(workflowsRoot, options = {}) {
    this.workflowsRoot = workflowsRoot;
    this.config = { ...DEFAULT_CONFIG, ...options };
    this.discoveredComponents = new Map(); // workflowName -> componentName[]
    this.lastGeneratedHashes = new Map(); // path -> hash of content
  }

  /**
   * Discovers all component directories matching the scan patterns.
   * 
   * @returns {Map<string, string>} Map of workflow name to components directory path
   */
  discoverComponentDirectories() {
    const componentDirs = new Map();
    
    if (!fs.existsSync(this.workflowsRoot)) {
      console.warn(`[workflow-ui-discovery] Workflows root does not exist: ${this.workflowsRoot}`);
      return componentDirs;
    }

    const entries = fs.readdirSync(this.workflowsRoot, { withFileTypes: true });
    
    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      
      const workflowName = entry.name;
      const componentsPath = path.join(this.workflowsRoot, workflowName, 'components');
      
      if (fs.existsSync(componentsPath) && fs.statSync(componentsPath).isDirectory()) {
        componentDirs.set(workflowName, componentsPath);
      }
    }

    return componentDirs;
  }

  /**
   * Scans a components directory for component files.
   * 
   * @param {string} componentsDir - Path to the components directory
   * @returns {string[]} Array of component filenames (without path)
   */
  scanComponentFiles(componentsDir) {
    if (!fs.existsSync(componentsDir)) {
      return [];
    }

    const files = fs.readdirSync(componentsDir);
    const components = [];

    for (const file of files) {
      const filePath = path.join(componentsDir, file);
      const stat = fs.statSync(filePath);
      
      // Skip directories
      if (stat.isDirectory()) continue;
      
      // Check extension
      const ext = path.extname(file);
      if (!this.config.componentExtensions.includes(ext)) continue;
      
      // Check exclude patterns
      if (matchesExcludePattern(file, this.config.excludeFiles)) continue;
      
      components.push(file);
    }

    return components.sort();
  }

  /**
   * Generates the content for an index.js file based on discovered components.
   * 
   * @param {string[]} componentFiles - Array of component filenames
   * @returns {string} The generated index.js content
   */
  generateIndexContent(componentFiles) {
    const header = this.config.generatedFileHeader.replace(
      '{{timestamp}}',
      new Date().toISOString()
    );

    if (componentFiles.length === 0) {
      return `${header}// No components found in this directory\nexport {};\n`;
    }

    const imports = [];
    const exports = [];

    for (const file of componentFiles) {
      const componentName = extractComponentName(file);
      const importPath = `./${file.replace(/\.(js|jsx|ts|tsx)$/, '')}`;
      
      if (this.config.indexTemplate === 'cjs') {
        // CommonJS format
        imports.push(`const ${componentName} = require('${importPath}');`);
        exports.push(`  ${componentName}: ${componentName}.default || ${componentName},`);
      } else {
        // ESM format (default)
        imports.push(`export { default as ${componentName} } from '${importPath}';`);
      }
    }

    if (this.config.indexTemplate === 'cjs') {
      return `${header}${imports.join('\n')}\n\nmodule.exports = {\n${exports.join('\n')}\n};\n`;
    }

    // ESM format
    return `${header}${imports.join('\n')}\n`;
  }

  /**
   * Generates the root registry content that lists all workflows and their components.
   * 
   * @param {Map<string, string[]>} workflowComponents - Map of workflow name to component names
   * @returns {string} The generated registry content
   */
  generateRootRegistryContent(workflowComponents) {
    const header = this.config.generatedFileHeader.replace(
      '{{timestamp}}',
      new Date().toISOString()
    );

    const lines = [];
    const registryEntries = [];
    const metadataEntries = [];
    const availableWorkflows = [];
    
    for (const [workflowName, components] of workflowComponents) {
      if (workflowName === '_shared') {
        // Special handling for shared components
        lines.push(`// Shared components available to all workflows`);
        lines.push(`export * as shared from './_shared/components/index.js';`);
        lines.push(``);
      } else if (workflowName !== 'scripts') {
        availableWorkflows.push(workflowName);
        const importPath = `./${workflowName}/components/index.js`;
        registryEntries.push(`  '${workflowName}': () => import('${importPath}'),`);
        
        // Add metadata entry
        metadataEntries.push(`  ${workflowName}: {`);
        metadataEntries.push(`    name: '${workflowName}',`);
        metadataEntries.push(`    description: '${workflowName.replace(/([A-Z])/g, ' $1').trim()} Workflow',`);
        metadataEntries.push(`    componentsPath: './${workflowName}/components'`);
        metadataEntries.push(`  },`);
      }
    }

    // Add available workflows constant
    lines.push(`// Available workflows in this registry`);
    lines.push(`const AVAILABLE_WORKFLOWS = [`);
    for (const name of availableWorkflows) {
      lines.push(`  '${name}',`);
    }
    lines.push(`];`);
    lines.push(``);

    // Add workflow metadata
    lines.push(`// Workflow metadata`);
    lines.push(`const workflowMetadata = {`);
    lines.push(...metadataEntries);
    lines.push(`};`);
    lines.push(``);

    // Add helper functions
    lines.push(`/**`);
    lines.push(` * Get list of available workflows`);
    lines.push(` */`);
    lines.push(`export const getLoadedWorkflows = () => AVAILABLE_WORKFLOWS;`);
    lines.push(``);
    lines.push(`/**`);
    lines.push(` * Get metadata for a specific workflow`);
    lines.push(` */`);
    lines.push(`export const getWorkflow = (workflowName) => workflowMetadata[workflowName] || null;`);
    lines.push(``);
    lines.push(`/**`);
    lines.push(` * Initialize workflows`);
    lines.push(` */`);
    lines.push(`export const initializeWorkflows = () => {`);
    lines.push(`  console.log('[Workflows] Initialized with:', AVAILABLE_WORKFLOWS);`);
    lines.push(`};`);
    lines.push(``);

    // Add lazy-loading registry for dynamic imports
    lines.push(`/**`);
    lines.push(` * Lazy-loading registry for workflow components.`);
    lines.push(` * Use this for code-splitting and dynamic imports.`);
    lines.push(` */`);
    lines.push(`export const workflowRegistry = {`);
    lines.push(...registryEntries);
    lines.push(`};`);
    lines.push(``);
    lines.push(`/**`);
    lines.push(` * Dynamic import helper for workflow components`);
    lines.push(` */`);
    lines.push(`export const loadWorkflowComponents = async (workflowName) => {`);
    lines.push(`  const workflow = workflowMetadata[workflowName];`);
    lines.push(`  if (!workflow) {`);
    lines.push(`    throw new Error(\`Unknown workflow: \${workflowName}\`);`);
    lines.push(`  }`);
    lines.push(`  const module = await import(\`./\${workflowName}/components/index.js\`);`);
    lines.push(`  return module.default || module;`);
    lines.push(`};`);
    lines.push(``);
    lines.push(`export default {`);
    lines.push(`  getLoadedWorkflows,`);
    lines.push(`  getWorkflow,`);
    lines.push(`  initializeWorkflows,`);
    lines.push(`  loadWorkflowComponents`);
    lines.push(`};`);

    return `${header}${lines.join('\n')}\n`;
  }

  /**
   * Checks if a workflow has a config file (e.g., theme_config.json).
   * 
   * @param {string} workflowName - Name of the workflow
   * @returns {boolean} True if the workflow has a config file
   */
  hasWorkflowConfig(workflowName) {
    const configPath = path.join(
      this.workflowsRoot,
      workflowName,
      this.config.workflowConfigFile
    );
    return fs.existsSync(configPath);
  }

  /**
   * Generates a workflow-level index.js that exports workflow metadata.
   * Only generated if the workflow has a theme_config.json (or configured config file).
   * 
   * @param {string} workflowName - Name of the workflow
   * @returns {string} The generated workflow index content
   */
  generateWorkflowIndexContent(workflowName) {
    const header = this.config.generatedFileHeader.replace(
      '{{timestamp}}',
      new Date().toISOString()
    );

    // Convert workflow name to a display name (e.g., "AppGenerator" -> "App Generator")
    const displayName = workflowName.replace(/([A-Z])/g, ' $1').trim();

    const lines = [
      `/**`,
      ` * ${workflowName} Workflow (frontend module)`,
      ` *`,
      ` * NOTE:`,
      ` * - UI tool rendering in ChatUI is dynamically routed via \`WorkflowUIRouter\``,
      ` *   using \`workflows/<WorkflowName>/components/index.js\`.`,
      ` * - This file exports workflow metadata and configuration.`,
      ` */`,
      ``,
      `import themeConfig from './${this.config.workflowConfigFile}';`,
      ``,
      `export const ${workflowName}Workflow = {`,
      `  id: '${workflowName}',`,
      `  name: '${displayName}',`,
      `  description: '${displayName} Workflow',`,
      `  config: themeConfig,`,
      `};`,
      ``,
      `export default ${workflowName}Workflow;`,
    ];

    return `${header}${lines.join('\n')}\n`;
  }

  /**
   * Writes content to a file only if it has changed.
   * This prevents unnecessary file system writes and rebuilds.
   * 
   * @param {string} filePath - Path to write to
   * @param {string} content - Content to write
   * @returns {boolean} True if the file was written, false if unchanged
   */
  writeIfChanged(filePath, content) {
    if (fs.existsSync(filePath)) {
      const existingContent = fs.readFileSync(filePath, 'utf8');
      
      // Compare content (ignoring timestamp in header)
      const normalizeForComparison = (str) => 
        str.replace(/Generated: .+/g, 'Generated: [timestamp]');
      
      if (normalizeForComparison(existingContent) === normalizeForComparison(content)) {
        return false; // No change needed
      }
    }

    fs.writeFileSync(filePath, content, 'utf8');
    return true;
  }

  /**
   * Runs the full discovery and generation process.
   * 
   * @returns {DiscoveryResult} Result object with statistics
   */
  run() {
    const result = {
      workflowsScanned: 0,
      componentsFound: 0,
      indexFilesGenerated: 0,
      indexFilesUnchanged: 0,
      errors: [],
      workflows: {}
    };

    console.log(`[workflow-ui-discovery] Scanning: ${this.workflowsRoot}`);

    const componentDirs = this.discoverComponentDirectories();
    result.workflowsScanned = componentDirs.size;

    const workflowComponents = new Map();

    for (const [workflowName, componentsDir] of componentDirs) {
      try {
        const componentFiles = this.scanComponentFiles(componentsDir);
        const componentNames = componentFiles.map(extractComponentName);
        
        workflowComponents.set(workflowName, componentNames);
        this.discoveredComponents.set(workflowName, componentNames);
        
        result.componentsFound += componentFiles.length;
        result.workflows[workflowName] = componentNames;

        // Generate index.js for this workflow
        const indexContent = this.generateIndexContent(componentFiles);
        const indexPath = path.join(componentsDir, 'index.js');
        
        const wasWritten = this.writeIfChanged(indexPath, indexContent);
        if (wasWritten) {
          result.indexFilesGenerated++;
          console.log(`  ✓ Generated: ${workflowName}/components/index.js (${componentFiles.length} components)`);
        } else {
          result.indexFilesUnchanged++;
          console.log(`  ○ Unchanged: ${workflowName}/components/index.js`);
        }

        // Generate workflow-level index.js if config file exists
        if (this.config.generateWorkflowIndex && workflowName !== '_shared' && this.hasWorkflowConfig(workflowName)) {
          const workflowIndexContent = this.generateWorkflowIndexContent(workflowName);
          const workflowIndexPath = path.join(this.workflowsRoot, workflowName, 'index.js');
          
          const workflowIndexWritten = this.writeIfChanged(workflowIndexPath, workflowIndexContent);
          if (workflowIndexWritten) {
            result.indexFilesGenerated++;
            console.log(`  ✓ Generated: ${workflowName}/index.js (workflow metadata)`);
          } else {
            result.indexFilesUnchanged++;
            console.log(`  ○ Unchanged: ${workflowName}/index.js`);
          }
        }
      } catch (error) {
        result.errors.push({ workflow: workflowName, error: error.message });
        console.error(`  ✗ Error processing ${workflowName}: ${error.message}`);
      }
    }

    // Generate root registry if enabled
    if (this.config.generateRootRegistry && workflowComponents.size > 0) {
      try {
        const registryContent = this.generateRootRegistryContent(workflowComponents);
        const registryPath = path.join(this.workflowsRoot, 'index.js');
        
        const wasWritten = this.writeIfChanged(registryPath, registryContent);
        if (wasWritten) {
          result.indexFilesGenerated++;
          console.log(`  ✓ Generated: workflows/index.js (root registry)`);
        } else {
          result.indexFilesUnchanged++;
          console.log(`  ○ Unchanged: workflows/index.js (root registry)`);
        }
      } catch (error) {
        result.errors.push({ workflow: '_root', error: error.message });
        console.error(`  ✗ Error generating root registry: ${error.message}`);
      }
    }

    console.log(`[workflow-ui-discovery] Complete: ${result.componentsFound} components across ${result.workflowsScanned} workflows`);
    
    return result;
  }

  /**
   * Regenerates the index for a specific workflow.
   * Used by the file watcher when changes are detected.
   * 
   * @param {string} workflowName - Name of the workflow to regenerate
   * @returns {boolean} True if the index was updated
   */
  regenerateWorkflow(workflowName) {
    const componentsDir = path.join(this.workflowsRoot, workflowName, 'components');
    
    if (!fs.existsSync(componentsDir)) {
      console.warn(`[workflow-ui-discovery] Components directory not found: ${componentsDir}`);
      return false;
    }

    const componentFiles = this.scanComponentFiles(componentsDir);
    const indexContent = this.generateIndexContent(componentFiles);
    const indexPath = path.join(componentsDir, 'index.js');
    
    const wasWritten = this.writeIfChanged(indexPath, indexContent);
    
    if (wasWritten) {
      console.log(`[workflow-ui-discovery] Regenerated: ${workflowName}/components/index.js`);
      
      // Also regenerate root registry
      if (this.config.generateRootRegistry) {
        this.regenerateRootRegistry();
      }
    }
    
    return wasWritten;
  }

  /**
   * Regenerates just the root registry.
   */
  regenerateRootRegistry() {
    const componentDirs = this.discoverComponentDirectories();
    const workflowComponents = new Map();
    
    for (const [workflowName, componentsDir] of componentDirs) {
      const componentFiles = this.scanComponentFiles(componentsDir);
      const componentNames = componentFiles.map(extractComponentName);
      workflowComponents.set(workflowName, componentNames);
    }

    const registryContent = this.generateRootRegistryContent(workflowComponents);
    const registryPath = path.join(this.workflowsRoot, 'index.js');
    
    this.writeIfChanged(registryPath, registryContent);
  }
}

/**
 * @typedef {Object} DiscoveryResult
 * @property {number} workflowsScanned - Number of workflow directories scanned
 * @property {number} componentsFound - Total number of components found
 * @property {number} indexFilesGenerated - Number of index files written
 * @property {number} indexFilesUnchanged - Number of index files that didn't need updating
 * @property {Array<{workflow: string, error: string}>} errors - Any errors encountered
 * @property {Object<string, string[]>} workflows - Map of workflow names to component names
 */

export default WorkflowComponentDiscovery;
